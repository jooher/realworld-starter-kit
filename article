Dap vs. Svelte на примере Real World Application

В предыдущем туториале мы написали на dap тестовое веб-приложение TodoMVC. Dap-решение оказалось в среднем в 10-20 раз компактнее решений на реакте, ангуляре и вот этом всем подобном. Что, впрочем, было вполне ожидаемо, и сюрпризом не стало.
Но соревноваться в стройности с откормленными свиноматками - это не очень спортивно, поэтому давайте сравним dap с восходящей звездой фронтендостроения - "магически исчезающим" Svelte. В метрике Real World Comparison  https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075/ тестовое приложение Conduit уместилось в 10кБ, что неплохо на фоне 150кБ Angular, 97кБ React+MobX, 42кБ Vue (метрика учитывает только js-файлы в сжатом виде; CSS и прочее оформительство у всех претендентов стандартное и метрике не учитывается).
Посмотрим, что получится, если написать Conduit на dap.

1. Структура приложения.
Как и в случае с TodoMVC, логично было бы использовать предоставляемые регламентом CSS-стили, поэтому и DOM-структуру нашего dap-приложения тоже берем из регламента. Окинув регламентные шаблоны непристальным взглядом, отмечаем: в отличие от TodoMVC, здесь HTML уже весьма развесист. Вручную его срисовывать желания нет, поэтому просто напишем несложный конвертер, который сам построит нам dap-заготовку из заданного HTML:

<code>
const

	$ = indent => el => {

		if(el.nodeType==3){
			const txt=el.nodeValue.trim();
			return txt ? indent+',"'+txt+'"' : '';
		}

		const
			
			sig = ([el.tagName] // сигнатура элемента включает в компактной форме его тег, 
				.concat([...el.classList]).join('.') // CSS-классы 
				+(el.id ? "#"+el.id : '') // и id.
				).replace(/^DIV\.?/,""), // если тег DIV, то его можно не указывать
			
			atr = el.attributes.length ? ([...el.attributes]
				.filter(a=>a.name!="class"&&a.name!="id") // прочие атрибуты
				.map(a=>' '+a.name+(a.value ? '="'+a.value+'"':'')) // указываются в полной форме
				.join(""))
				: '',
			
			d = el.childNodes.length ? [...el.childNodes] // дочерние элементы будут перечисляться в d-правиле
				.map($(indent+'	')) // не забываем про индентацию
				.join("")+indent : '' ;

		return  indent + ",'"+ sig + atr +"'" +'.d(""' + d + ")"; //
	},

	tgt=document.body;

tgt.textContent=$("\n")(tgt);
tgt.style.whiteSpace="pre";
</code>

Далее собираем весь HTML из регламента в отдельный .html-файл, дописываем в него этот код, весело забираем результат, сохраняем в новый файл (назовем его conduit.dap.js). И уже начинаем радоваться, что dap-заготовка у нас есть - и руками рисовать ее не пришлось, а можно сразу приступать к написанию логики - но тут нас поджидает...

1.1. Боль
...довольно-таки неприятный сюрприз. При более пристальном рассмотрении оказывается, что регламентный текст HTML-шаблонов как-то по-дэбильному написан. Шаблоны очевидно писались исходя не из логики приложения, а из визуальной разметки. Отсюда и дикие имена CSS-классов, и - самое неприятное - нелогичная группировка элементов. В общем, улыбка покидает наше лицо.
Дело в том, что работа с плохо структурированным приложением в dap - это боль. Кто-то скажет, что боль это плохо, но я не соглашусь. Боль - это адекватная реакция на то, что плохо, и чего не должно быть. Хорошее должно приносить радость и удовольствие, плохое - боль и страдания. И dap как раз об этом. В отличие от... ну да ладно.
Но мы же не любим боль? Поэтому нам ничего не остается, как отступиться от регламента и покромсать регламентные шаблоны, приведя их в соответствие с логикой приложения. Но ведь тогда поплывет CSS? Да. Такова цена. Придется вмешаться и в CSS.



. Там же берем регламентный HTML head с прописанными стилями, и

2. API
API к бэкенду описан здесь: https://github.com/gothinkster/realworld/tree/master/api


